using System.IO;
using System.Text;
using UnityEngine;
using SimpleXML;

public class XmlWriter : IConfigWriter
{
    public ConfigFormat SupportedFormat => ConfigFormat.Xml;

    public void Write(string outputPath, ConfigData data, WriterOptions options = null)
    {
        options = options ?? new WriterOptions();

        using (var stream = new FileStream(outputPath, FileMode.Create, FileAccess.Write))
        using (var writer = new StreamWriter(stream, options.Encoding))
        {
            // 写入XML声明
            writer.WriteLine($"<?xml version=\"1.0\" encoding=\"{options.Encoding.WebName}\"?>");

            // 写入文件头注释
            if (options.AddComment)
            {
                writer.WriteLine("<!--");
                writer.WriteLine("Auto-generated config file");
                writer.WriteLine("Generated by ConfigConvertTool");
                writer.WriteLine($"PrimitiveFormat: {data.PrimitiveFormat}");
                writer.WriteLine($"Mode: {data.Mode}");
                writer.WriteLine("-->");
                writer.WriteLine();
            }

            switch (data.Mode)
            {
                case ConfigMode.Array:
                    WriteArray(writer, data, options);
                    break;
                case ConfigMode.KeyValue:
                    WriteKeyValue(writer, data, options);
                    break;
                default:
                    Debug.LogError($"不支持的配置模式: {data.Mode}");
                    break;
            }
        }
    }

    private void WriteArray(StreamWriter writer, ConfigData data, WriterOptions options)
    {
        // 直接写入数组元素
        var itemName = data.Columns.Length > 0 ? data.Columns[0] : "Item";

        // 直接循环写入子元素，不添加根节点
        foreach (var row in data.Rows)
        {
            writer.WriteLine($"{GetIndent(options.Indent, 0)}<{itemName}>"); // 缩进从0开始

            for (int j = 0; j < data.Columns.Length; j++)
            {
                var fieldName = data.Columns[j];
                var fieldValue = row[j];
                var indent = GetIndent(options.Indent, 1); // 子节点缩进+1

                writer.Write($"{indent}<{fieldName}>");
                writer.Write(FormatXmlValue(fieldValue));
                writer.WriteLine($"</{fieldName}>");
            }

            writer.WriteLine($"{GetIndent(options.Indent, 0)}</{itemName}>"); // 闭合标签缩进0
        }
    }

    private void WriteKeyValue(StreamWriter writer, ConfigData data, WriterOptions options)
    {
        if (data.RootNode != null)
        {
            WriteTreeNode(writer, data.RootNode, options.Indent, 0);
        }
        else
        {
            // 空内容时不写入任何根节点
            writer.WriteLine();
        }
    }

    private void WriteTreeNode(StreamWriter writer, TreeNode node, string indent, int depth)
    {
        var currentIndent = GetIndent(indent, depth);
        var childIndent = GetIndent(indent, depth + 1);
        
        // 处理数组元素的节点名称：如果节点名是纯数字，添加前缀
        var nodeName = IsNumericNodeName(node.Name) ? $"Item{node.Name}" : node.Name;
        nodeName = EscapeXmlName(nodeName);

        // 开始节点标签
        writer.Write($"{currentIndent}<{nodeName}");

        // 写入属性
        if (node.Attributes.Count > 0)
        {
            foreach (var attr in node.Attributes)
            {
                var attrName = EscapeXmlName(attr.Key);
                var attrValue = FormatXmlAttributeValue(attr.Value);
                writer.Write($" {attrName}=\"{attrValue}\"");
            }
        }

        // 处理值节点和空节点
        if (node.NodeType == TreeNodeType.Value || 
            (node.NodeType == TreeNodeType.Object && node.Children.Count == 0 && node.Attributes.Count == 0))
        {
            if (node.NodeType == TreeNodeType.Value)
            {
                writer.Write($">{FormatXmlValue(node.Value)}</{nodeName}>");
            }
            else
            {
                writer.Write(" />");
            }
            writer.WriteLine();
            return;
        }

        // 非值节点且有子节点
        writer.WriteLine(">");

        // 写入子节点
        foreach (var child in node.Children)
        {
            WriteTreeNode(writer, child, indent, depth + 1);
        }

        // 闭合节点
        writer.WriteLine($"{currentIndent}</{nodeName}>");
    }

    /// <summary>
    /// 判断节点名称是否为纯数字（需要添加前缀的情况）
    /// </summary>
    private bool IsNumericNodeName(string name)
    {
        if (string.IsNullOrEmpty(name))
            return false;
            
        // 检查是否全部由数字组成
        foreach (char c in name)
        {
            if (!char.IsDigit(c))
                return false;
        }
        return true;
    }

    /// <summary>
    /// 获取指定深度的缩进字符串
    /// </summary>
    private string GetIndent(string baseIndent, int depth)
    {
        return string.Concat(System.Linq.Enumerable.Repeat(baseIndent, depth));
    }

    /// <summary>
    /// 格式化XML元素值（处理转义）
    /// </summary>
    private string FormatXmlValue(object value)
    {
        if (value == null)
            return "";

        return XML.Escape(value.ToString());
    }

    /// <summary>
    /// 格式化XML属性值（处理转义）
    /// </summary>
    private string FormatXmlAttributeValue(object value)
    {
        if (value == null)
            return "";

        // 属性值需要额外转义引号
        return XML.Escape(value.ToString())
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");
    }

    /// <summary>
    /// 转义XML节点/属性名称（简单处理，实际可能需要更复杂的规则）
    /// </summary>
    private string EscapeXmlName(string name)
    {
        if (string.IsNullOrEmpty(name))
            return "node";

        // 替换非法字符
        return name.Replace(" ", "_")
                  .Replace("<", "_")
                  .Replace(">", "_")
                  .Replace("&", "_")
                  .Replace("\"", "_")
                  .Replace("'", "_");
    }
}