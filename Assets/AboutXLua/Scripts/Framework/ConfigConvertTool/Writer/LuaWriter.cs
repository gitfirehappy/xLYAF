using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;

public class LuaWriter : IConfigWriter
{
    public ConfigFormat SupportedFormat => ConfigFormat.Lua;

    public void Write(string outputPath, ConfigData data, WriterOptions options = null)
    {
        options = options ?? new WriterOptions();

        using (var stream = new FileStream(outputPath, FileMode.Create, FileAccess.Write))
        using (var writer = new StreamWriter(stream, options.Encoding))
        {
            // 写入文件头注释
            if (options.AddComment)
            {
                writer.WriteLine("-- Auto-generated config file");
                writer.WriteLine("-- Generated by ConfigConvertTool");
                writer.WriteLine("-- PrimitiveFormat: " + data.PrimitiveFormat);
                writer.WriteLine("-- Mode: " + data.Mode);
                writer.WriteLine();
            }

            switch (data.Mode)
            {
                case ConfigMode.Array:
                    WriteArray(writer, data, options);
                    break;
                case ConfigMode.KeyValue:
                    WriteKeyValue(writer, data, options);
                    break;
                default:
                    Debug.LogError($"不支持的配置模式: {data.Mode}");
                    break;
            }
        }
    }

    private void WriteArray(StreamWriter writer, ConfigData data, WriterOptions options)
    {
        writer.WriteLine("return {");

        for (int i = 0; i < data.Rows.Count; i++)
        {
            var row = data.Rows[i];
            writer.Write($"{options.Indent}{{");

            for (int j = 0; j < data.Columns.Length; j++)
            {
                var fieldName = data.Columns[j];
                var fieldValue = row[j];

                writer.Write($"[\"{fieldName}\"] = {FormatLuaValue(fieldValue)}");
                if (j < data.Columns.Length - 1)
                {
                    writer.Write(", ");
                }
            }

            writer.Write("}");
            if (i < data.Rows.Count - 1)
            {
                writer.Write(",");
            }

            writer.WriteLine();
        }

        writer.WriteLine("}");
    }

    private void WriteKeyValue(StreamWriter writer, ConfigData data, WriterOptions options)
    {
        writer.WriteLine("return {");
        if (data.RootNode != null)
        {
            WriteTreeNode(writer, data.RootNode, options.Indent, 1,false);
        }

        writer.WriteLine("}");
    }

    private void WriteTreeNode(StreamWriter writer, TreeNode node, string indent, int depth, bool isArrayElement)
    {
        var currentIndent = GetIndent(indent, depth);
        var childIndent = GetIndent(indent, depth + 1);

        // 如果不是数组元素，写入节点名称
        if (!isArrayElement)
        {
            writer.Write($"{currentIndent}[\"{node.Name}\"] = ");
        }

        switch (node.NodeType)
        {
            case TreeNodeType.Object:
                writer.WriteLine("{");
                // 写入属性
                for (int i = 0; i < node.Attributes.Count; i++)
                {
                    var attr = node.Attributes.ElementAt(i);
                    writer.Write($"{childIndent}[\"@{attr.Key}\"] = {FormatLuaValue(attr.Value)}");
                    // 属性间用逗号分隔，最后一个属性不写逗号
                    if (i < node.Attributes.Count - 1)
                        writer.WriteLine(",");
                    else
                        writer.WriteLine(); // 最后一个属性单独换行
                }

                // 写入子节点
                for (int i = 0; i < node.Children.Count; i++)
                {
                    var child = node.Children[i];
                    WriteTreeNode(writer, child, indent, depth + 1, false);
                    // 子节点间用逗号分隔，最后一个子节点不写逗号
                    if (i < node.Children.Count - 1)
                        writer.WriteLine(",");
                    else
                        writer.WriteLine(); // 最后一个子节点单独换行
                }

                writer.WriteLine($"{currentIndent}}}"); // 闭合符单独占一行
                break;

            case TreeNodeType.Array:
                writer.WriteLine("{");
                for (int i = 0; i < node.Children.Count; i++)
                {
                    var child = node.Children[i];
                    writer.Write(childIndent);
                    // 数组元素直接写值，不写键名
                    WriteTreeNodeValue(writer, child, indent, depth + 1);
                    if (i < node.Children.Count - 1)
                        writer.WriteLine(",");
                }

                writer.WriteLine($"{currentIndent}}}");
                break;

            case TreeNodeType.Value:
                writer.Write(FormatLuaValue(node.Value));
                break;
        }
    }

    /// <summary>
    /// 写入节点值（用于数组元素）
    /// </summary>
    private void WriteTreeNodeValue(StreamWriter writer, TreeNode node, string indent, int depth)
    {
        switch (node.NodeType)
        {
            case TreeNodeType.Object:
            case TreeNodeType.Array:
                WriteTreeNode(writer, node, indent, depth, true);
                break;
            default:
                writer.Write(FormatLuaValue(node.Value));
                break;
        }
    }

    /// <summary>
    /// 获取指定深度的缩进字符串
    /// </summary>
    private string GetIndent(string baseIndent, int depth)
    {
        return string.Concat(System.Linq.Enumerable.Repeat(baseIndent, depth));
    }

    /// <summary>
    /// 格式化Lua值（处理不同类型和转义）
    /// </summary>
    private string FormatLuaValue(object value)
    {
        if (value == null)
            return "nil";

        // 处理字符串类型
        if (value is string str)
        {
            // 转义特殊字符
            str = str.Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\'", "\\\'")
                .Replace("\n", "\\n")
                .Replace("\r", "\\r")
                .Replace("\t", "\\t");

            return $"\"{str}\"";
        }

        // 处理布尔类型
        if (value is bool boolVal)
        {
            return boolVal ? "true" : "false";
        }

        // 处理数字类型（直接返回）
        if (value is int || value is float || value is double || value is decimal)
        {
            return value.ToString();
        }

        // 默认转为字符串
        return $"\"{value}\"";
    }
}